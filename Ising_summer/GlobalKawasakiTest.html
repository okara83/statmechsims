
<!DOCTYPE html>
<!--
Much of the HTML5 adaptation of this code comes from that of Dan Schroeder (Weber State University) -- http://physics.weber.edu/schroeder/software/demos/IsingModel.html
-->
<html>
    <head>
        <title>Ising Model</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="shortcut icon" href="">
        <style>
            body {text-align: center;}
            .sideBySide { /*makes elements display side by side */
                display:inline-block;
                vertical-align: top;
                margin-bottom: 1cm;  /*also adds vertical space after block */
            }
             .verticalSpace {
                margin-bottom: .5cm;
            } 
            
            input[type = number]{
                width: 60px;
            }
            
        </style>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    </head>
    <body>
        <div>
            <h1> Ising Model </h1>
        </div>
        
        <div class = "sideBySide">
            <canvas id ="theCanvas" width ="600" height ="600"> Canvas not supported on this browser </canvas>
        </div> 
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
        <div class = "sideBySide"> 
            <p><b> Data </b></p>
            <div><input type ="button" value ="Reset Stats" onclick ="resetData()"/></div>
            <div class = "verticalSpace"><table border="1" width="3" cellpadding="4">
                   <thead>
                   </thead>
                   <tbody>
                       <tr>
                           <td>Steps</td>
                           <td id = "Steps">0</td>
                       </tr>
                       <tr>
                           <td>Energy</td>
                           <td id = "Energy">0</td>
                       </tr>
                       <tr>
                           <td>Average Energy</td>
                           <td id = "Eav">0</td>
                       </tr>
                       <tr>
                           <td>Sigma Energy</td>
                           <td id = "SigmaE">0</td>
                       </tr>
                       <tr>
                           <td>Magnetization</td>
                           <td id = "M">0</td>
                       </tr>
                       <tr>
                           <td>Average Magnetization</td>
                           <td id = "Mav">0</td>
                       </tr>
                       <tr>
                           <td>Sigma Magnetization</td>
                           <td id = "SigmaM">0</td>
                       </tr>
                   </tbody>
               </table>
            </div>
            
            <p> <b> Nanotube Settings: </b></p>
            <div>Thickness: <input type ="number" id ="nThicknessInput" value = "2" min ="0" max ="150"/> </div>
            <div>Diameter: <input type ="number" id ="nDiameterInput" value = "15" min ="0" max ="298"/> </div>
            <div>Height: <input type ="number" id ="nHeightInput" value ="50" min ="0" max ="300"/> </div>
            <div>Spin: <select id = "nSpinSelect">
                    <option>Positive</option>
                    <option>Negative</option>
                </select> </div>
            <div class = "verticalSpace"> <input type="button" value="Create Nanotube" onclick = "makeNanotube()"/> </div>
            <div> <p id = "molRatioReadout">Mole Ratio: .5 Up and .5 Down</p><input type ="range" min ="0" id ="molRatioSlider" onchange = "changeMolRatio()"/> </div> 
            <div class ="verticalSpace"><input type ="button" value ="Execute Mole Ratio" onclick ="execMolRatio()"/> </div>
            <div><p id = "spfReadout"> Steps Per Frame: 10000</p> <input type ="range" min ="1" max ="7" value = "4" id = "spfSlider" onchange = "changeSpf()"/> </div>
       </div>
        
        <div class = "verticalSpace">
            Temperature: <input type="number" id ="tempInput" step = "0.01" value ="2.27" onchange = "changeT()" min = "0.0"/>
            &nbsp; &nbsp;
            Magnetic Field: <input type="number" id ="BfieldInput" step = "0.01" value ="0.0" onchange = "changeBfield()"/>
            &nbsp; &nbsp;
            <select id ="magnetSelect" onchange = "changeMagnet()">
                <option>Ferromagnetic</option>
                <option>Anti-Ferromagnetic</option>
                <option>Bipartite</option>
            </select>
            &nbsp; &nbsp;
            Size: <select id="sizeSelect" onchange = "resize()">
                    <option>3</option>
                    <option>4</option>
                    <option>5</option>
                    <option>8</option>
                    <option>10</option>
                    <option>25</option>
                    <option>40</option>
                    <option>50</option>
                    <option>75</option>
                    <option>100</option>
                    <option>200</option>
                    <option>300</option>
                </select>
            &nbsp; &nbsp;
            <select id = "algorithmSelect" onchange = "changeAlgorithm()">
                <option>Metropolis</option>
                <option>Kawasaki</option>
            </select>
            &nbsp; &nbsp;
            <select id = "boundarySelect" onchange = "changeBoundaries()">
                <option>Periodic Boundaries</option>
                <option>Anti-periodic Boundaries (both directions)</option>
                <option>Anti-periodic Boundaries (one direction)</option>
                <option>Isolated Boundaries</option>
                <option>Plus-Minus Boundaries (one direction)</option>
                <option>Skewed Plus Minus Boundaries</option>
                <option>Plus Boundaries (both directions)</option>
                <option>Minus Boundaries (both directions)</option>
            </select>
        </div>
        <div class = "verticalSpace"> 
            Show Fixed Spin: <input type = "checkbox" id = "showSpin" onclick = "changeShowSpin()"/>
            &nbsp;&nbsp; 
            Local Magnetic Field: <input type = "number" id ="SettleB" value ="0.0" min ="-10.0" max ="10.0" onchange = "changeSettleB()"/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           <input type ="button" value ="Randomize" id ="randomizeButton" onclick ="randomize()"/>
            &nbsp;&nbsp;
           <input type ="button" value ="Align" onclick ="makeAllOneColor()"/>
           &nbsp;&nbsp;
           <input type ="button" value ="Restart" onclick ="restart()" id = "restartButton" disabled>
           &nbsp;&nbsp;
           <input type ="button" value ="Restart with Aligned Lattice" onclick ="restartFromAligned()"/>
           &nbsp;&nbsp;
           <input type="button" value="Restart with Random Lattice" onclick="restartFromRandom()" />
        </div>
        
        
        <div class = "verticalSpace"> <input type="button" value=" Start " id="startButton" onclick ="startStop()"/> </div>
        
       
        <div class = "verticalSpace">
            Filename to Save As: <input id="inputFileNameToSaveAs"/>
            <input type ="button" value ="Save" onclick="saveTextAsFile()"/>
        </div>
        
        <div> 
            Select a file to load: <input type ="file" id ="fileToLoad" onclick = "enableOpen()"/>
            <input type="button" value ="Open" onclick="loadFileAsText()" disabled id = "openButton"/>
        </div>
        
        <p id ="show"></p>
        
        
        
        <script> 
             //variables from html, organized by how they appear top to bottom, left to right on the webpage
             
            
            var canvas = document.getElementById("theCanvas");
            var context = canvas.getContext("2d");
            var nThicknessInput = document.getElementById("nThicknessInput");// n = nanotube
            var nDiameterInput = document.getElementById("nDiameterInput");
            var nHeightInput = document.getElementById("nHeightInput");
            var nSpinSelect = document.getElementById("nSpinSelect");
            var molRatioSlider = document.getElementById("molRatioSlider"); //mol = mole
            var molRatioReadout = document.getElementById("molRatioReadout");
            var spfReadout = document.getElementById("spfReadout");
            var spfSlider = document.getElementById("spfSlider");
            var tempInput = document.getElementById("tempInput"); 
            var BfieldInput = document.getElementById("BfieldInput"); 
            var magnetSelect = document.getElementById("magnetSelect");
            var sizeSelect = document.getElementById("sizeSelect");
            var algorithmSelect = document.getElementById("algorithmSelect");
            var boundarySelect = document.getElementById("boundarySelect");
            var showSpinCheck = document.getElementById("showSpin");
            var SettleBInput = document.getElementById("SettleB");
            var startButton = document.getElementById("startButton");
            var show = document.getElementById("show"); //for testing purposes

            //data
            var InnerLoopCount = 0; 
            var StepsPerLoop = Math.pow(10, Number(spfSlider.value)); // this*innerLoopCount rounded to the nearest hundredth = steps that are shown 
    
            var Ecurrent = 0.0; //energy of current loops in algorithm
            var EsquaredTotal = 0.0; // declared to calculate sigmaE
            var Etotal = 0.0; //total energy, declared to calculate average energy
            
            var Mcurrent = 0.0; //magnetization of loop
            var MsquaredTotal = 0.0; //see EsquaredTotal
            var Mtotal = 0.0; //total magnetization, used in average
            
            //inputs
            
            var T = Number(tempInput.value); //temperature
            var zeroT = false; //true when t = 0
            
            var Bfield = Number(BfieldInput.value); //magnetic field
            
            //initialize magnet options
            magnetSelect.selectedIndex = 0; //ferromagnetic is the default
            var CouplingConstant;
            if(magnetSelect.value == "Ferromagnetic")
                CouplingConstant = 1;
            else   
                CouplingConstant = -1;


            //size
            sizeSelect.selectedIndex = 9;//default is 100
            var Size = Number(sizeSelect.options[sizeSelect.selectedIndex].text);  // dimensions of lattice
            var SquareWidth = canvas.width/Size; //size of each square determined by size of lattice
            var upRatio = 0.0; //for when you use the mol ratio creator slider/button, decimal of "up" spins
            changeMolRatioSettings();
            
            //algorithm
            algorithmSelect.selectedIndex = 0; //default is metropolis
            var metropolis;
            if (algorithmSelect.value == "Metropolis")
                metropolis = true;
            else
                metropolis = false; //runs kawasaki
            
            //boundary conditions
            boundarySelect.selectedIndex = 0; //default is regular pbc
            var pbc = true; 
            var ApbcBothDirections = false; 
            var ApbcOneDirection = false;
            var FreeBound = false; //for isolated boundaries
            //for all boundary condiitons below, they are really just pbc with fixed positive or negative edges
            var PlusMinus = false; 
            var skewedPlusMinus = false;
            var plusBothDirections = false;
            var minusBothDirections = false;
            
            var showSpin = showSpinCheck.checked; // if true will show in a different color the squares that are manually changed

            
            var SettleB = SettleBInput.value; //Dipole Settle Mode-what the square will flip to when it is clicked on
           
            var maxSize = canvas.width; //used in resize()
            var running = false; //true when running
            
            //sets local magnetic field of all dipoles to zero initially
            var BfieldM = new Array(Size);
            for (var i = 0; i < Size; i++){
                BfieldM[i] = new Array(Size);
                for (var j = 0; j < Size; j++){
                    BfieldM[i][j] = 0;
                }
            }
            
            //sets a random 2D array of dipoles and colors them accordingly
            var s = new Array(Size);  
				 for (var i = 0; i < Size; i++){
           			     s[i] = new Array(Size);
             			   for (var j = 0; j < Size; j++){
              			      if(Math.random() < 0.5){
               			         s[i][j] = 1}
               			    else {s[i][j] = -1}
               			    colorSquare(i, j); 	
               			     	}
                			}
             var upSpin = new Object();
		   	 var downSpin = new Object();
		   	 //var allSpins = new Object();
		   	 var ups = 0;
		   	 var downs = 0;
           		for (var m = 0; m < Size; m++){
        			for (var n = 0; n < Size; n++){
      		    		if(s[m][n] > 0){
                	    	var ordered = [m,n];                        	
                	    	upSpin[ups] = ordered;
                	    	//allSpins[m+n] = [ordered,1];
                	    	ups= ups +1;
                	    	} 
                	    	else {
                  			var ordered = [m,n];
                   			downSpin[downs] = ordered;
                   			//allSpins[m+n] = [ordered,-1];
        					downs = downs+1;
                    			}
                    		}
                    	}     			
                			
            
					
           //these will be defined when someone saves a configuration so that the user can easily go back to the initial saved configuration     
            var initS;
            var initBfieldM;
            var initSettings;
            
            //computes current energy of original lattice before simulation begins (resetData() then resets the averages, not current energy)
            if (metropolis)
                ComputeEforMetropolis();
            else
                ComputeEforKawasaki();
            resetData();
            
            simulate();
            
           
             
           

            function simulate(){
                if(running){
                    if(metropolis)
                        Metropolis();
                    else
                        MetropolisforKawasaki();
                    Cumulate();
                }
                DisplayData();
                window.setTimeout(simulate, 1); //comes back in 1 millisecond
                
            }
            // runs the metropolis algorithm and colors squares accordingly    
            function Metropolis() {
                for(var step = 0; step < StepsPerLoop; step++){
                    var i = Math.floor(Math.random()*Size);
                    var j = Math.floor(Math.random()*Size);
                    thisS = s[i][j];
                    var Ediff = deltaU(i,j);
                    var EdiffforM = deltaUforM(i,j);
                    if(zeroT){ //to avoid dividing by zero
                        if((EdiffforM < 0.0) || ((EdiffforM == 0) && (Math.random() < .5))){ //always flip if deltaU is negative or if deltaU is 0 then flip randomly
                            thisS *= -1;
                            s[i][j] = thisS;
                            colorSquare(i,j);
                            Ecurrent += Ediff;
                            Mcurrent += (2*thisS); 
                        }
                        //if deltaU is positive then there is no flip when at absolute zero
                    }
                    else if((EdiffforM <= 0.0) || (Math.random() < Math.exp((-EdiffforM)/T))){
                        thisS *= -1;
                        s[i][j] = thisS;
                        colorSquare(i,j);
                        Ecurrent += Ediff;
                        Mcurrent += (2*thisS);
                        
                    }
                }
                InnerLoopCount++;
                
            }
         
        
       
             
timelap = 0;   
t = performance.now();            
        function MetropolisforKawasaki(){
           		var t0 = performance.now();
                for(var step = 0; step <StepsPerLoop; step++){
                	var keyup = Math.floor(Math.random()*ups);
                	var keydown = Math.floor(Math.random()*downs);
                	var randUp= upSpin[keyup];
                	var randDown= downSpin[keydown];
                    //if(true){
                   // console.log('up',Object.keys(upSpin).length);
                   // }
                   // if(true){
                   // console.log('down',Object.keys(downSpin).length);
                   // }
        			var i1 = randUp[0];
        			var j1 = randUp[1];
                    var i2 = randDown[0];
                    var j2 = randDown[1];
                    //var i1 = Math.floor(Math.random()*Size);
                    //var j1 = Math.floor(Math.random()*Size);
                    //var i2 = Math.floor(Math.random()*Size);
                    //var j2 = Math.floor(Math.random()*Size); 
                	var thisS = s[i1][j1];
                	var thatS = s[i2][j2];
                	if(s[i1][j1] != s[i2][j2]){
                    var EdiffforM = deltaUforKawasakiforM(i1, j1, i2, j2);
                    var Ediff = deltaUforKawasaki(i1, j1, i2, j2);
                    if(zeroT){ //to avoid dividing by zero
                           if((EdiffforM < 0.0) || ((EdiffforM == 0) && (Math.random() < .5))){ //always flip if deltaU is negative
                               thisS *= -1;
                               s[i1][j1] = thisS;
                               upSpin[keyup] = [i2,j2];
                               thatS *= -1;
                               s[i2][j2] = thatS;
                               downSpin[keydown]=[i1,j1];
                               colorSquare(i1, j1);
                               colorSquare(i2, j2);
                               Ecurrent += Ediff;
                               Mcurrent += ((2*thisS) + (2*thatS));
                           }
                           }
                    else if ((EdiffforM <= 0.0) || (Math.random() < Math.exp((-EdiffforM)/T))){
                            thisS *= -1;
                            s[i1][j1] = thisS;
                            upSpin[keyup] = [i2,j2];
                            thatS *= -1;
                            s[i2][j2] = thatS;
                            downSpin[keydown]=[i1,j1];
                            colorSquare(i1, j1);
                            colorSquare(i2, j2);
                            Ecurrent += Ediff;
                            Mcurrent += ((2*thisS) + (2*thatS));
                        }
                    }
                    }
                    InnerLoopCount++;
                    var t1 = performance.now();
     	      		timelap += (t1 - t0);
              		readit = timelap/InnerLoopCount
          	    	console.log(readit);
                }
          
                
                
            
            

            // energy change without local magnetic field
            function deltaU(i,j){
                var left = getLeft(i,j);
                var right = getRight(i,j);
                var top = getTop(i,j);
                var bottom = getBottom(i,j); 
                var thisS = s[i][j];
                return (2.0 * CouplingConstant * thisS * (top+bottom+left+right)+2.0 * thisS * Bfield)
            }
            
            //computes energy change if dipole s[i][j] is flipped with local magnetic field
            function deltaUforM(i, j){
                var left = getLeft(i,j);
                var right = getRight(i,j);
                var top = getTop(i,j);
                var bottom = getBottom(i,j); 
                var thisS = s[i][j];
                
                return (2.0 * CouplingConstant * thisS * (top+bottom+left+right))+ (2.0 * thisS *(Bfield+BfieldM[i][j]));
            }
            
            // energy change for kawaskai without local magnetic field
            function deltaUforKawasaki(i1,j1, i2, j2){
                var thisS = s[i1][j1];
                var thatS = s[i2][j2];
                
                var left1 = getLeft(i1,j1);
                var right1 = getRight(i1,j1);
                var top1 = getTop(i1,j1);
                var bottom1 = getBottom(i1,j1);
                
                var left2 = getLeft(i2,j2);
                var right2 = getRight(i2,j2);
                var top2 = getTop(i2,j2);
                var bottom2 = getBottom(i2,j2);
                
                if ((j2 == 0 && j1 == Size - 1 && i2 == i1) || (j2 == Size - 1 && j1 == 0 && i2 == i1) || (i2 == 0 && i1 == Size - 1 && j2 == j1)
                || (i2 == Size - 1 && i1 == 0 && j2 == j1)) {
                    if (pbc || ApbcBothDirections || ApbcOneDirection || PlusMinus)
                      return (2.0*CouplingConstant*thisS*(bottom1 + top1 + left1 + right1) + 
                          2.0*CouplingConstant*thatS*(bottom2 + top2 + left2 + right2) + 
                          4.0*CouplingConstant + 2.0*thisS*(Bfield+BfieldM[i1][j1]) + 2.0*thatS*(Bfield+BfieldM[i2][j2]));
                    else if (FreeBound)
                      return (2.0*CouplingConstant*thisS*(bottom1 + top1 + left1 + right1) + 
                          2.0*CouplingConstant*thatS*(bottom2 + top2 + left2 + right2) + 
                          2.0*thisS*(Bfield+BfieldM[i1][j1]) + 2.0*thatS*(Bfield+BfieldM[i2][2]));
                  }
                else if ((j2 == j1+1 && i2 == i1) || (j1 == j2 + 1 && i1 == i2) || (j2 == j1-1 && i2 == i1) || 
                (j1 == j2 - 1 && i1 == i2) || (j2 == j1 && i2 == i1+1) || (j1 == j2 && i1 == i2 + 1) || 
                (j2 == j1 && i2 == i1-1 || j1 == j2 && i1 == i2 - 1))
                    return (2.0*CouplingConstant*thisS*(bottom1 + top1 + left1 + right1) + 
                        2.0*CouplingConstant*thatS*(bottom2 + top2 + left2 + right2) + 
                        4.0*CouplingConstant + 2.0*thisS*(Bfield+BfieldM[i1][j1]) + 2.0*thatS*(Bfield+BfieldM[i2][j2]));
                else
                    return (2.0*CouplingConstant*thisS*(bottom1 + top1 + left1 + right1) + 
                        2.0*CouplingConstant*thatS*(bottom2 + top2 + left2 + right2) + 
                        2.0*thisS*(Bfield+BfieldM[i1][j1]) + 2.0*thatS*(Bfield+BfieldM[i2][j2]));
              

                
            }
            
            //energy change with local magnetic field
            function deltaUforKawasakiforM(i1, j1, i2, j2){
                var thisS = s[i1][j1];
                var thatS = s[i2][j2];
                var left1 = getLeft(i1,j1);
                var right1 = getRight(i1,j1);
                var top1 = getTop(i1,j1);
                var bottom1 = getBottom(i1,j1);
                var left2 = getLeft(i2,j2);
                var right2 = getRight(i2,j2);
                var top2 = getTop(i2,j2);
                var bottom2 = getBottom(i2,j2);
                
                
                if (((j2 == j1+1) && i2 == i1) || ((j1 == j2 + 1) && i1 == i2) || ((j2 == j1-1) && (i2 == i1)) 
                || (j1 == j2 - 1 && i1 == i2) || (j2 == j1 && i2 == i1+1) || (j1 == j2 && i1 == i2 + 1) ||
                (j2 == j1 && i2 == i1-1) || (j1 == j2 && i1 == i2 - 1)){
                    return 2.0*CouplingConstant*thisS*(bottom1 + top1 + left1 + right1) + 2.0*CouplingConstant*thatS*(bottom2 + top2 + left2 + right2) + 4.0*CouplingConstant + 2.0*thisS*(Bfield+BfieldM[i1][j1]) + 2.0*thatS*(Bfield+BfieldM[i2][j2]);
                  
              }
                else
                  return 2.0*CouplingConstant*thisS*(bottom1 + top1 + left1 + right1) + 2.0*CouplingConstant*thatS*(bottom2 + top2 + left2 + right2) + 2.0*thisS*(Bfield+BfieldM[i1][j1]) + 2.0*thatS*(Bfield+BfieldM[i2][j2]);

                
            }
            
            //returns the dipole to the left of s[i][j] taking into account boundary conditions
            function getLeft(i, j){
                if (j == 0) {
                    if(pbc) //or any other boundary condition not listed here:
                        return s[i][Size -1];
                    
                    else if(ApbcBothDirections)
                        return -s[i][Size -1];
                        
                    else if (ApbcOneDirection)
                        return -s[i][Size -1];

                    else if(FreeBound)
                        return 0;
                        
                    }
                
                else
                    return s[i][j-1];
                
            }

 
            function getRight(i, j){
                if (j == Size-1) {
                    if(pbc)
                        return s[i][0];
                    else if (ApbcBothDirections)
                        return -s[i][0];
                    else if (ApbcOneDirection)
                        return -s[i][0];
                    else if (FreeBound)
                        return 0;
                }    
                   else
                     return s[i][j+1];
            }
            //dipole above s[i][j] with boundary conditions
            function getTop(i, j){
                if (i==0)
                 {
                    if(pbc)
                        return s[Size-1][j];
                    else if (ApbcBothDirections)
                        return -s[Size-1][j];
                    else if (ApbcOneDirection)
                        return s[Size-1][j];
                    else if (FreeBound)
                        return 0;
                 }
                 else
                     return s[i-1][j];
            }
            //dipole below with boundary conditions
            function getBottom(i,j){
                if (i==Size-1){
                     if(pbc)
                         return s[0][j];
                     else if (ApbcBothDirections)
                         return -s[0][j];
                     else if (ApbcOneDirection)
                         return s[0][j];
                     else if (FreeBound)
                         return 0;
                 }
                 else
                     return s[i+1][j];
            }
             //adds in stats of the current loop
            function Cumulate(){
                Etotal += Ecurrent;
                EsquaredTotal += (Ecurrent*Ecurrent);
                Mtotal += Mcurrent;
                MsquaredTotal += (Mcurrent*Mcurrent);
            }
            
            //changes data display of energy and magnitization
            function DisplayData(){
                var Steps, Eav, Esquaredav, SigmaE, Mav, Msquaredav, SigmaM;
                if(InnerLoopCount == 0){
                    Steps = 0;
                    Eav = 0.0;
                    SigmaE = 0.0;
                    Mav = 0.0;
                    SigmaM = 0.0;
                }
                else{
                    if(StepsPerLoop >= 100)
                        Steps = InnerLoopCount*(StepsPerLoop/100)*100;
                    else
                        Steps = InnerLoopCount*StepsPerLoop; //can't round off to hundreths place if stepsPerLoop is below 100
                    Eav = Etotal/InnerLoopCount;
                    var Esquaredav = EsquaredTotal/InnerLoopCount;
                    SigmaE = Math.sqrt(Esquaredav-(Eav*Eav));
                    Mav = Mtotal/InnerLoopCount;
                    Msquaredav = MsquaredTotal/InnerLoopCount;
                    SigmaM = Math.sqrt(Msquaredav - (Mav*Mav));
                }
                var sizeSquared = Size*Size;
                var data = [Steps, Ecurrent, Eav, SigmaE, Mcurrent, Mav, SigmaM];
                var dataNames =["Steps", "Energy", "Eav", "SigmaE", "M", "Mav", "SigmaM"];
                document.getElementById(dataNames[0]).innerHTML = data[0]; //because number of steps is the only data that doesn't have to be divided by sizeSquared
                for(var i = 1; i < data.length; i++){ //starts at "Energy", looping through the two arrays saves space
                    document.getElementById(dataNames[i]).innerHTML = (data[i]/sizeSquared).toFixed(3);
                
            }
        }
            //computes total energy from scratch when using the metropolis algorithm
            function ComputeEforMetropolis(){
                Ecurrent = 0.0;
                Mcurrent = 0.0;
                for(var i=0; i<Size; i++){
                    for(var j=0; j<Size; j++){
                        var right = getRight(i,j);
                        var bottom = getBottom(i,j);
                        var thisS = s[i][j];
                        Ecurrent = Ecurrent - CouplingConstant*thisS*(right+bottom)-thisS*Bfield;
                        Mcurrent+= thisS;
                    }
                }
            }
            //computes total energy from scratch when using the kawasaki algorithm
            function ComputeEforKawasaki(){
                Ecurrent = 0.0;
                Mcurrent = 0.0;
                for(var i=0; i<Size; i++){
                    for(var j=0; j<Size; j++){
                        var right = getRight(i,j);
                        var left = getLeft(i,j);
                        var top = getTop(i,j);
                        var bottom = getBottom(i,j);
                        var thisS = s[i][j];
                        Ecurrent = Ecurrent - .5*CouplingConstant*thisS*(right+left+top+bottom)-thisS*Bfield
                        Mcurrent += thisS;
                    }
                }
            }
            
              
            //jquery for setting the spin by clicking on a square
            $(document).ready(function(){
                
                //for when the mouse is dragged or clicked
                var mouseDown = false;
                
                var oldI, oldJ, newI, newJ; //so it doesn't flip the spin more than once in one square we distinguish between old and new
                $("canvas").mousedown(function(event){
                    mouseDown = true;
                    
                    var offSet = $(this).offset();
                    var x = event.pageX - offSet.left,
                        y = event.pageY - offSet.top;
                    
                    oldI = Math.floor(y/SquareWidth);
                    oldJ = Math.floor(x/SquareWidth);
                    setSpin(oldI,oldJ);
                    
                });
                $(document).mouseup(function(event){
                    mouseDown = false;
                });
                //make an unset square button
                $("canvas").mousemove(function(event){
                    if(mouseDown){
                        var offSet = $(this).offset();
                        var x = event.pageX - offSet.left,
                            y = event.pageY - offSet.top;
                        newI = Math.floor(y/SquareWidth);
                        newJ = Math.floor(x/SquareWidth);
                        if((newI != oldI) || (newJ != oldJ))
                        {
                            oldI = newI;
                            oldJ = newJ;
                            setSpin(newI, newJ);
                        }                        
                    }
                });
        });
            function setSpin(i, j){
                
                if(SettleB == 0.0){
                    Ecurrent += deltaUforM(i,j); //update energy value
                    s[i][j] *= -1;
                    Mcurrent += (2.0*s[i][j]);//update magnetization value
                    
                }
                else{ // only changes value/color if the SettleB and previous value don't match
                    if (s[i][j] == 1 && SettleB < -0.1)  {
                        Ecurrent += deltaUforM(i,j);
                        s[i][j] *= -1;
                        Mcurrent += (2.0*s[i][j]);  
                        }
                    else if(s[i][j] == -1 && SettleB >0.1){
                        Ecurrent += deltaUforM(i,j);
                        s[i][j] *= -1;
                        Mcurrent += (2.0*s[i][j]);
                       
                    }
                }
                BfieldM[i][j] = SettleB; //make sure local magnetic field is updated
                colorSquare(i,j);
                }
                
             //colors a certain square, taking into account if it has been set manually and if it's set to bipartite
            function colorSquare(i, j) {
                    if(!showSpin && BfieldM[i][j] == 100)// basically if the square is part of a nanotube it will be a darker blue
                        context.fillStyle = "#00008B";
                    else if(!showSpin && BfieldM[i][j] == -100)
                        context.fillStyle = "#FFD700"; //or a darker yellow
                    else if(showSpin && BfieldM[i][j] > .0001)
                        context.fillStyle = '#ff0000';
                    
                    else if (showSpin && BfieldM[i][j] < -.0001)
                        context.fillStyle = '#008000';
                    
                    
                    else{
                        if((magnetSelect.selectedIndex == 2) && (i%2 == j%2)){
                            if(s[i][j] == 1)
                                context.fillStyle = '#ffff00';
                            else
                                context.fillStyle = '#0000ff';
                        }
                        else{
                            if(s[i][j]== 1)
                                context.fillStyle = '#0000ff';
                            else
                                context.fillStyle = '#ffff00';
                        }
                    }
                       
                    context.fillRect(j*SquareWidth, i*SquareWidth, SquareWidth,SquareWidth);
        }
            
            function colorAll(){
                for(var i = 0; i < Size; i++)
                {
                    for(var j = 0; j < Size; j++){
                        colorSquare(i,j);
                    }
                }
            }
            
            function colorAllAndResetBfieldM(){ //recolors squares and resets Bfield (for use in the boundary conditions)
                for(var i = 0; i < Size; i++)
                {
                    for(var j = 0; j < Size; j++){
                        BfieldM[i][j] = 0;
                        colorSquare(i,j);
                    }
                }
            }
            //these functions all have to do with the buttons in the html and are organized by their order of appearance from top to bottom, left to right
            
            //resets tables (except for current energy and magnetization)
            function resetData(){
                InnerLoopCount = 0;
                Etotal = 0;
                EsquaredTotal = 0;
                Mtotal = 0;
                MsquaredTotal = 0;
                DisplayData();
            }
            
           
           //makes a nanotube of set spins shown in dark yellow or blue
           function makeNanotube(){
                BfieldInput.value = 0;
                changeBfield();
                tempInput.value = 1;
                changeT();
                var nThickness = Number(nThicknessInput.value);
                var nDiameter = Number(nDiameterInput.value);
                var nHeight = Number(nHeightInput.value);
                if(nSpinSelect.selectedIndex == 0)
                    nSpin = 1;
                else
                    nSpin = -1;
                s[0][0] = nSpin; //makes sure it will color everything else the opposite of what the tubes are
                makeAllOneColor();
                var leftIndex = (Math.round(Size/2) - 1) - (Math.round(nDiameter/2) + (nThickness - 1));
                var rightIndex = leftIndex + (nThickness - 1) + (nDiameter + 1);
                var topIndex = (Math.round(Size/2) - 1) - (Math.round(nHeight/2)-1);
                var bottomIndex = topIndex + nHeight;
                
                for(var i = topIndex; i < bottomIndex; i++){
                    for(var j = leftIndex; j < leftIndex + nThickness; j++){
                        s[i][j] *= -1;
                        BfieldM[i][j] = 100 * nSpin;
                        colorSquare(i, j);
                        }
                }
                for(var i = topIndex; i < bottomIndex; i++){
                    for(var j = rightIndex; j < rightIndex + nThickness; j++){
                        s[i][j] *= -1;
                        BfieldM[i][j] = 100 * nSpin;
                        colorSquare(i, j);
                        }
                }
                
                if (metropolis)
                    ComputeEforMetropolis();
                else
                    ComputeEforKawasaki();
                
                resetData();
           }
           
           function changeNanotubeSettings(){
                nDiameterInput.value = Math.floor(Size/2); //makes sure the default nanotube isn't bigger than the lattice
                nThicknessInput.value = Math.floor(Size/8) + 1;
                nHeightInput.value = Math.floor(Size/2);
                nDiameterInput.max = Size - 2; //makes sure you can't make a nanotube that's bigger than the lattice
                nThicknessInput.max = Math.floor(Size/2);
                nHeightInput.max = Size;
           }
           
           function changeMolRatioSettings(){//also changes readout and slider value
               //ratios available depend on the size of the lattice so they can evenly divide into the size
               if(Size%4 == 0){
                   molRatioSlider.value = 2;
                   molRatioSlider.max = 4;  
               }
               else if(Size%5 == 0){
                   molRatioSlider.value = 3;
                   molRatioSlider.max = 5;
               }
               else if(Size%3 == 0){
                   molRatioSlider.value = 1;
                   molRatioSlider.max = 3;
               }
              changeMolRatio();              
           }
           
           function changeMolRatio(){//ONLY changes readout 
               var v = Number(molRatioSlider.value);
               
               if(Size%4 == 0)
                   upRatio = v/4;
               
               else if(Size%5 == 0)
                   upRatio = v/5;
               
               else if(Size%3 == 0)
                   upRatio = v/3;
               var downRatio = (1 - upRatio).toFixed(2);
               molRatioReadout.innerHTML = "Mole Ratio: " + upRatio+ " Up and " + downRatio + " Down";
           }
           
           function execMolRatio(){//actually creates the mole ratio
               var middleIndex = upRatio*Size; //where the "up" part will end and the "down" part will start in the lattice
               var topSpin = -s[0][0]; //decides the spin of the top part of the lattice by taking the opposite of the current spin (so when you press "executemolratio" again, it  flip the color of the top and bottom part)
               for(i = 0; i < middleIndex; i++){
                   for(j = 0; j< Size; j++){
                       s[i][j] = topSpin;
                       BfieldM[i][j]= 0;
                       colorSquare(i,j);
                   }
               }
               for(i = middleIndex; i <Size; i++){
                   for(j= 0; j<Size; j++){
                       s[i][j] = -topSpin;
                       BfieldM[i][j] = 0;
                       colorSquare(i,j);
                   }
               }
               if (metropolis)
                    ComputeEforMetropolis();
               else
                    ComputeEforKawasaki();
               resetData();
           }
           
           function changeSpf(){
               StepsPerLoop = Math.pow(10, Number(spfSlider.value));
               spfReadout.innerHTML = " Steps Per Frame: " + StepsPerLoop;
           }
           
           function changeT(){
                T = Number(tempInput.value);
                if(T==0)
                    zeroT = true;
                else
                    zeroT = false;
                
            }
            function changeBfield(){
                Bfield = Number(BfieldInput.value);
            }
            
            function changeMagnet(){
                if(magnetSelect.selectedIndex == 0) //if it's ferromagnetic
                    CouplingConstant = 1;
                else
                    CouplingConstant = -1;
                colorAll(); //have to recolor all the squares if its been change from or to bipartite
                    
                
            }
            
            
            
            //resizes lattice
            function resize() {
                // First up-sample the lattice into a temporary array at max resolution:
                var tempS = new Array(maxSize);
                for (var i=0; i<maxSize; i++) {
                    tempS[i] = new Array(maxSize);
                    for (var j=0; j<maxSize; j++) {
                        var iOld = Math.floor(i / SquareWidth);
                        var jOld = Math.floor(j / SquareWidth);
                        tempS[i][j] = s[iOld][jOld];
                    }
                }
                // Get new size from GUI selector:
                Size = Number(sizeSelect.options[sizeSelect.selectedIndex].text);
                SquareWidth = canvas.width / Size;
                // Now re-create the spin array, down-sampling from temporary array
                s = new Array(Size);
                BfieldM = new Array(Size);
                upSpin = new Object();
		   	    downSpin = new Object();
		   	  	 	
                			
                    	
                for (var iNew=0; iNew<Size; iNew++) {
                    s[iNew] = new Array(Size);
                    BfieldM[iNew] = new Array(Size);
                    for (var jNew=0; jNew<Size; jNew++) {
                        var sTotal = 0;
                                                //iterates through one square in the new lattice
                        for (var i=iNew*SquareWidth; i<(iNew+1)*SquareWidth; i++) {
                            for (var j=jNew*SquareWidth; j<(jNew+1)*SquareWidth; j++) {
                            sTotal += tempS[i][j];
                            }
                        }
                        if (sTotal > 0) {
                            s[iNew][jNew] = 1;// average determines down-sampled value of that square
                            //upSpin[iNew+jNew]=[iNew,jNew]
                        } 
                        else if (sTotal < 0) {
                            s[iNew][jNew] = -1;
                            //downSpin[iNew+jNew]=[iNew,jNew]
                        } 
                        else { // resolve ties with a random number
                            if (Math.random() < 0.5){
                            s[iNew][jNew] = 1; 
                           // upSpin[iNew+jNew]=[iNew,jNew];
                            }
                            else{
                            s[iNew][jNew] = -1;
                           // downSpin[iNew+jNew]=[iNew,jNew]
                        }
                        }
                        BfieldM[iNew][jNew] = 0;
                        colorSquare(iNew, jNew);
                    }
                }
                   			
                
                resetData();
                    
                if (metropolis)
                     ComputeEforMetropolis();
                else
                ComputeEforKawasaki(); 
            
               changeNanotubeSettings(); 
               changeMolRatioSettings();
                
	}
        
            
            
            
            
            function changeAlgorithm(){
                metropolis = !metropolis;
            }
            
            function changeBoundaries(){
                pbc = false; 
                ApbcBothDirections = false; 
                ApbcOneDirection = false;  
                //only set them true if select says they are
                if(boundarySelect.selectedIndex == 0){
                    pbc = true; 
                    colorAllAndResetBfieldM();
                }

                else if(boundarySelect.selectedIndex == 1){
                    ApbcBothDirections = true; 
                    colorAllAndResetBfieldM();
                }

                else if(boundarySelect.selectedIndex == 2){
                    ApbcOneDirection = true; 
                    colorAllAndResetBfieldM(); 
                }
                
                else if(boundarySelect.selectedIndex ==3){
                    FreeBound = true;
                    colorAllAndResetBfieldM();
                }
                //everything below just uses pbc but have skewed borders
                else if(boundarySelect.selectedIndex == 4){
                    pbc = true; //other than top and bottom rows, all other boundaries are the same as pbc
                    for(var j = 0; j < Size; j++){ //sets the top and bottom rows to be either positive or negative with a large local magnetic field
                        s[0][j] = 1;
                        BfieldM[0][j] = 100;
                        colorSquare(0,j);
                        
                        s[Size-1][j] = -1;
                        BfieldM[Size-1][j] = -100;
                        colorSquare(Size-1, j);
                    }
                }
                else if(boundarySelect.selectedIndex == 5){
                    pbc = true; 
                    for(var j = 0; j < Size; j++){ 
                        s[0][j] = 1;
                        BfieldM[0][j] = 100;
                        colorSquare(0,j);
                        
                        s[Size-1][j] = -1;
                        BfieldM[Size-1][j] = -100;
                        colorSquare(Size-1, j);
                    }
                    
                    for(var i = 0; i < Size; i++){
                        s[i][0] = 1;
                        BfieldM[i][0] = 100;
                        colorSquare(i,0);
                        
                        s[i][Size-1] = -1;
                        BfieldM[i][Size-1] = -100;
                        colorSquare(i, Size-1);
                    }
                }
                else if(boundarySelect.selectedIndex == 6){
                   pbc = true; 
                    for(var j = 0; j < Size; j++){ 
                        s[0][j] = 1;
                        BfieldM[0][j] = 100;
                        colorSquare(0,j);
                        
                        s[Size-1][j] = 1;
                        BfieldM[Size-1][j] = 100;
                        colorSquare(Size-1, j);
                    }
                    
                    for(var i = 0; i < Size; i++){
                        s[i][0] = 1;
                        BfieldM[i][0] = 100;
                        colorSquare(i,0);
                        
                        s[i][Size-1] = 1;
                        BfieldM[i][Size-1] = 100;
                        colorSquare(i, Size-1);
                    }
                }
                else if(boundarySelect.selectedIndex == 7){
                    pbc = true; 
                    for(var j = 0; j < Size; j++){ 
                        s[0][j] = -1;
                        BfieldM[0][j] = -100;
                        colorSquare(0,j);
                        
                        s[Size-1][j] = -1;
                        BfieldM[Size-1][j] = -100;
                        colorSquare(Size-1, j);
                    }
                    
                    for(var i = 0; i < Size; i++){
                        s[i][0] = -1;
                        BfieldM[i][0] = -100;
                        colorSquare(i,0);
                        
                        s[i][Size-1] = -1;
                        BfieldM[i][Size-1] = -100;
                        colorSquare(i, Size-1);
                    }
                }
                
               if (metropolis)
                    ComputeEforMetropolis();
               else
                    ComputeEforKawasaki();
                resetData();
            }
            
            function changeShowSpin(){
                showSpin = !showSpin;
                colorAll();
            }
            
            function changeSettleB(){
                SettleB = Number(SettleBInput.value);
            }
            
            
      
            function randomize(){ //doesn't change fixed boundary conditions
               var startX; //where the algorithm starts horizontally depends on the boundary condition (so we don't change the fixed spins in the skewed boundary conditions)
               var endX; //where it ends horizontally
               var startY;
               var endY;
               //if it's fixed plus minus one way
               if(boundarySelect.selectedIndex == 4){
                   startX = 0;
                   endX = 0;
                   startY = 1;
                   endY = Size - 1;
               }
               //fixed plus minus both ways, plus both ways, or minus both ways
               else if(boundarySelect.selectedIndex > 4){
                   startX = 1;
                   endX = Size - 1;
                   startY = 1;
                   endY = Size - 1;
               }
               //for all other boundary conditions, there's no need to avoid the top or bottom row because there aren't any fixed spins
               else{
                   startX = 0;
                   endX = Size;
                   startY = 0;
                   endY = Size;
               }
               for (var i = startY; i < endY; i++){
                    for (var j = startX; j < endX; j++){
                        if(Math.random() < 0.5){
                            s[i][j] = 1;
                        }
                        else{
                            s[i][j] = -1;
                        }
                        BfieldM[i][j] = 0;
                        colorSquare(i, j);
                        }
                        
                    }

                
               if (metropolis)
                    ComputeEforMetropolis();
               else
                    ComputeEforKawasaki();
                resetData();
            }
            //colors all squares opposite of a square in the middle of the lattice, used in "align" button (doesn't mess with fixed boundary conditions)
            function makeAllOneColor(){
               var startX; //where the algorithm starts horizontally depends on the boundary condition (so we don't change the fixed spins in the skewed boundary conditions)
               var endX; //where it ends horizontally
               var startY;
               var endY;
               //if it's fixed plus minus one way
               if(boundarySelect.selectedIndex == 4){
                   startX = 0;
                   endX = 0;
                   startY = 1;
                   endY = Size - 1;
               }
               //fixed plus minus both ways, plus both ways, or minus both ways
               else if(boundarySelect.selectedIndex > 4){
                   startX = 1;
                   endX = Size - 1;
                   startY = 1;
                   endY = Size - 1;
               }
               //for all other boundary conditions, there's no need to avoid the top or bottom row because there aren't any fixed spins
               else{
                   startX = 0;
                   endX = Size;
                   startY = 0;
                   endY = Size;
               }
               var middle = Math.round(Size/2) - 1;
               s[middle][middle] *= -1; //opposite of this middle square's color so you can flip back and forth by clicking it again
               for(var i = startY; i < endY; i++){
                   for(var j = startX; j < endX; j++){
                       s[i][j] = s[middle][middle];
                       BfieldM[i][j] = 0;
                       colorSquare(i,j);
                   }
               }
                
               if (metropolis)
                    ComputeEforMetropolis();
               else
                    ComputeEforKawasaki();
                resetData();
           }
           
           function restart(){ //to return to initial SAVED configuration (only enabled after the "open" button is pressed)
                for(var i = 0; i< Size; i++){
                    for(var j = 0; j < Size; j++){
                       BfieldM[i][j] = initBfieldM[i][j];
                       s[i][j] = initS;
                    }
                }
                var settings = [];
                for(var i = 0; i < initSettings.length; i++){
                    settings[i] = initSettings[i];
                }
               
               changeSettings(settings);
               colorAll();
               startStop();
           }
           
           function restartFromAligned(){ //DOES revert boundary conditions to periodic and gets rid of fixed spins
               var settings = [2.27, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0]; //default settings
               changeSettings(settings);
               makeAllOneColor();
               
               if (metropolis)
                    ComputeEforMetropolis();
               else
                    ComputeEforKawasaki();
               resetData();
               startStop();
           }
           
           function restartFromRandom(){
               var settings = [2.27, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0];
               changeSettings(settings);
               randomize();
              
               if (metropolis)
                    ComputeEforMetropolis();
               else
                    ComputeEforKawasaki();
               resetData();
               startStop();
           }
           
           
           //used in start button
            function startStop(){
                running = !running;
                if(running)
                    startButton.value = " Pause ";
                 
                else
                    startButton.value = " Start ";
               
                
            }
            //everything below has to do with saving
            //basically creates a text files, converts all necessary data into strings then has the capability to essentially 
            //recreate the lattice from an uploaded textfile
             
           
            function saveTextAsFile()
            {   
                var textToSave = makeSettingsString() + makeSpinArrayString() + "X"+ makeBfieldArrayString(); //"X" used as a divider between spin and Bfield array so it doesn't have to know how long each is
                var textToSaveAsBlob = new Blob([textToSave], {type:"text/plain"});
                var textToSaveAsURL = window.URL.createObjectURL(textToSaveAsBlob);
                var fileNameToSaveAs = document.getElementById("inputFileNameToSaveAs").value;
                
                //creates and destroys download link (otherwise it won't just let you download the textfile from a button)
                var downloadLink = document.createElement("a");
                downloadLink.download = fileNameToSaveAs;
                downloadLink.innerHTML = "Download File";
                downloadLink.href = textToSaveAsURL;
                downloadLink.onclick = destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);

                downloadLink.click();
                
            }

            function destroyClickedElement(event)
            {
                    document.body.removeChild(event.target);
            }
            
            function enableOpen(){
                document.getElementById("openButton").disabled = false;
            }

            function loadFileAsText()
            {
                document.getElementById("restartButton").disabled = false;
                var fileToLoad = document.getElementById("fileToLoad").files[0];

                var fileReader = new FileReader();
                fileReader.onload = function(fileLoadedEvent) 
                {
                    var textFromFileLoaded = fileLoadedEvent.target.result;
                    recreateLattice(textFromFileLoaded);
                };
                fileReader.readAsText(fileToLoad, "UTF-8");
            } 
            
           
            
            function recreateLattice(text){
                var settingsText = text.substring(0, text.indexOf("["));
                var sText = text.substring(text.indexOf("["), text.indexOf("X"));
                var BfieldText = text.substring(text.indexOf("X") + 1);
                var settings = JSON.parse("[" + settingsText + "]");
                changeSettings(settings);
                s = JSON.parse("[" + sText + "]");
                BfieldM = JSON.parse("[" + BfieldText + "]");
                for(var i = 0; i < Size; i++){
                    for(var j = 0; j < Size; j++){
                        s[i][j] = Number(s[i][j]);
                        
                        BfieldM[i][j] = Number(BfieldM[i][j]); //make sure the strings convert back to numbers
                        colorSquare(i,j);
                    }
                }
                //saved for "restart" button to return to initial saved configuration
                initBfieldM = new Array(Size);
                initS = new Array(Size);
                for(var i = 0; i < Size; i++){
                    initBfieldM[i] = new Array(Size);
                    initS[i] = new Array(Size);
                    for(var j = 0; j < Size; j++){
                        initBfieldM[i][j] = BfieldM[i][j];
                        initS[i][j] = s[i][j];
                    }
                }
                
                initSettings = new Array(settings.length);
                for(var i = 0; i < settings.length; i++){
                    initSettings[i] = settings[i];
                }
            }
            
            function makeSettingsString() {
                 var string =  "" + T + ", " + Bfield + ", " + magnetSelect.selectedIndex + ", " + sizeSelect.selectedIndex + ", " + algorithmSelect.selectedIndex + ", " + boundarySelect.selectedIndex + ", " + InnerLoopCount + ", " +  Ecurrent + ", " + EsquaredTotal + ", " + Etotal + ", " + Mcurrent + ", " + MsquaredTotal + ", " + Mtotal;
                 return string;
                 
             }
             
             function makeSpinArrayString() {
                 var string = "";
                 for(var i = 0; i<Size; i++){ 
                     string += "["; 
                     for(var j = 0; j<Size; j++){
                         if(j<Size-1)
                            string += "\"" + s[i][j] + "\", ";
                         else
                             string += "\"" + s[i][j] + "\"";
                     }
                     if(i<Size - 1)
                        string += "],";
                     else
                         string += "]";
                 }
                 return string;
             }
             
             function makeBfieldArrayString() {
                 var string = "";
                 for(var i = 0; i<Size; i++){ 
                     string += "[";
                     for(var j = 0; j<Size; j++){
                         if(j<Size-1)
                            string += "\"" + BfieldM[i][j] + "\", ";
                         else
                             string += "\"" + BfieldM[i][j] + "\"";
                     }
                     if(i<Size - 1)
                        string += "],";
                     else
                         string += "]";
                 }
                 return string;
             }
            
            function changeSettings(settings){
                
                tempInput.value = settings[0];
                changeT();
                BfieldInput.value = settings[1];
                changeBfield();
                magnetSelect.selectedIndex = settings[2];
                changeMagnet();
                sizeSelect.selectedIndex = settings[3];
                Size = Number(sizeSelect.options[sizeSelect.selectedIndex].text);
                SquareWidth = canvas.height/Size;
                changeNanotubeSettings();
                changeMolRatioSettings();
                algorithmSelect.selectedIndex = settings[4];
                changeAlgorithm();
                boundarySelect.selectedIndex = settings[5];
                changeBoundaries();
                InnerLoopCount = settings[6];
                Ecurrent = settings[7];
                EsquaredTotal = settings[8];
                Etotal = settings[9];
                Mcurrent = settings[10];
                MsquaredTotal = settings[11];
                DisplayData();
            }
            
        </script>
    </body>
</html>
